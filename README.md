# scheck

Playing around with ScalaCheck.


---

For a more extensive overview of the capabilities of ScalaCheck see the official [User Guide](https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md)


## Overview of ScalaCheck 

[ScalaCheck](http://www.scalacheck.org/) is a unit-testing framework (written in [Scala](http://www.scalacheck.org/)) for Scala and Java programs. ScalaCheck adopts the property-based approach of writing tests and provides several tools to make the testing more productive, the most significant being the ability to automatically generate test data. The framework therefore has the two following fundamental concepts:-

_**properties**_ - they test the output of a specifc function    
_**generators**_ - they generate random test data for the properties to test    


The idea is that the programmer defines the _properties_ (which test different aspects of a function), and the ScalaCheck library automatically generates random test data and checks that each property holds true for each instance of that test data. A property only _passes_ if it holds true for every generated piece of test data. This removes some of the burden on the programmer who now does not need to spend so much time thinking about writing tests for particular boundary cases and instead he/she can let the framework do much of the heavy lifting. The framework is also pretty savvy in that it is designed - when a property fails - to then go and find the _shortest_ failure path (explained further on). 


## Writing Properties

Here is a very simple property that just checks String concatenation. [Try it out yourself](#trying-it-out-in-the-scala-repl)

```scala
val concatStringStrtsWith = forAll { (s1: String, s2: String) => (s1 + s2).startsWith(s1) }
```

The above example uses ScalaCheck's `forAll` method - read this method as _"for all the randomly generated instances of test strings `s1` and `s2`, apply the predicate function"_. So, `forAll` takes a predicate function (takes some input, applies some logical test to it, and returns a boolean result of that test), and applies this to every instance of test data generated by ScalaCheck. If all generated test data pass the predicate 


## Can I Control the Generated Test Data?

By default, ScalaCheck properties created using the `forAll` method (for example) are _**Universally quantified**_. This means that we expect the property to be satisfied by every member of it's domain. In other words, if we write a universally quantified property that takes an `Int` as argument, then we expect that the property will hold for _"any"_ (ie. _"all"_) integers that we throw at it.

If you want to restrict the generated test data to some subset then you have a couple of ways to do this:-

#### Providing a Generator

The following test uses the specific `smallIntegers` data generator instead of the default integer generator in order to restrict the range of test integers to be between `0 - 1000`


```scala
import org.scalacheck._

val smallIntegers = Gen.choose(0,1000)

val propSmallInteger = Prop.forAll(smallIntegers) { n =>
  n >= 0 && n <= 1000
}
```

#### Filtering using the implication operator `==>`

The following test filters the set of integers so that it both ignores non-negative integers, as well as those over `10000`

```scala
import org.scalacheck.Prop.{forAll, BooleanOperators}

val propMakeList = forAll { n: Int =>
  (n >= 0 && n < 10000) ==> (List.fill(n)("").length == n)
}
```

## Generating Custom Data Types

ScalaCheck can generate basic data types (strings, integers, chars etc) automatically because it already understands them, but if we want to generate our own custom types then we need to write custom data generators for these types. Fortunately, writing custom generators is not a very complex task.


## Trying it out in the Scala REPL
<a name="repl"></a>

If you need to [install the Scala REPL](https://www.scala-lang.org/download/install.html)

[Download](http://repo1.maven.org/maven2/org/scalacheck/) a version of ScalaCheck if you do not have a copy already.

```scala
$ wget http://repo1.maven.org/maven2/org/scalacheck/scalacheck_2.12/1.13.5/scalacheck_2.12-1.13.5.jar
```

Note that we are assuming you are using some build of Scala 2.12.x on your system, so if you are using a different version then download a build of ScalaCheck compiled against your version.

Start the REPL and import the ScalaCheck jar onto the REPL classpath.

```scala
$ scala
Welcome to Scala 2.12.2 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_131).
Type in expressions for evaluation. Or try :help.

scala> :require scalacheck_2.12-1.13.5.jar
Added /Users/jonjack/scalacheck_2.12-1.13.5.jar to classpath.

// Tip - REPL commands can also be abbreviated
scala> :req scalacheck_2.12-1.13.5.jar
```

Now define some property to test.

```scala
scala> import org.scalacheck.Prop.forAll
import org.scalacheck.Prop.forAll

scala> val concatStringStartsWith = forAll { (s1: String, s2: String) => (s1 + s2).startsWith(s1) }
concatStringStrtsWith: org.scalacheck.Prop = Prop
```

Now we can run the tests.

```scala
scala> concatStringStrtsWith.check
+ OK, passed 100 tests.
```

There is a `collect` method which allows us to get some insight on the generated test data.

```scala
scala> concatStringStrtsWith2.check
+ OK, passed 100 tests.
> Collected test data:
1% (匉踵扫퓵鯖塶럑㒐즌൞ꌹꑱᇸ晠♈鼉۴⢳쨬ꀥ큿⛛潤鯶㔦➳ꘝઘᆵͱꞃ㗏鼗鄳ﱐ፥쀛뢎㐨硧䎮춹ꡤ쑏ǁ㒐갣쯜㶋ꗓ辿适,ꐷ黎晲ꧫ㬑퉱짞绍
  ☠ጴ಄贔䵄䘎ഏ勬篲퍈䠋뛪㵟)
1% (牦캌≂맑ࢻ釖춚睎죴飇餇✻ꬂ䧘濁흮珁麉蜢킾᣻佾繑䷜濗,絪폍̧ꏷ犻⯼黟煎羪㙯)
1% (澭愣﫧ⲃ诌᧎뵖ᜩ쌡뮺醼뉓噘ꃢ,ⵯമ࠽㾏ૢ禚裩︤偖䃅黄)
...
```

Note that automatic generation of strings includes characters from the whole utf-8 character set - hence you will not get a set of test data with readable content.





